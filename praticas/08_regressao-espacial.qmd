---
title: "Prática - Regressão Espacial"
---

::: callout-note
Essa prática foi adaptada do roteiro criado por [Luis Felipe Bortolatto da Cunha](luisfelipebr.github.io/mti2020/roteiros/roteiro7.html) para edições passadas dessa disciplina.
:::

::: callout-warning
## Download do arquivo `.qmd`

Sugestão: abra o projeto no RStudio (que está usando ao longo do curso), e faça o download deste arquivo (em formato `.qmd`) com o código abaixo.

```{r}
#| eval: false
download.file(
  url = "https://raw.githubusercontent.com/beatrizmilz/ESHT011-21-analise-dados-planejamento-territorial/refs/heads/main/praticas/08_regressa-espacial.qmd",
  destfile = "08_regressa-espacial.qmd",
)
```
:::

## Introdução

Este roteiro tem como objetivo auxiliar na execução de **modelos de regressão espacial** (Spatial Lag, Spatial Error e GWR) com o software R.

Para executar os modelos de regressão espacial vamos utilizar dados demográficos e de consumo de água de 2010, para uma amostra de 4.417 municípios, extraídos do Censo Demográfico (IBGE) e do Sistema Nacional de Informações sobre Saneamento (SNIS), conforme análise apresentada por [Carmo et al., 2013](https://abrh.s3.sa-east-1.amazonaws.com/Sumarios/155/ea6a64ffc76c211d6b7749ab8444b626_bf87b0b219dd784ffa049f367598e626.pdf).


A base de dados está disponível para download no endereço abaixo:

<https://1drv.ms/u/s!AjettDH-3Gbni9kP8cPtA04EBQQ7xQ?e=4dyWz5>

## Carregando os pacotes

Os pacotes necessários para essa prática são:

-   `tidyverse`: para manipulação e visualização de dados;

-   `sf`: para trabalhar com dados geoespaciais vetoriais (shapefile ou geopackage)

-   `spdep`: para calcular a autorrelação espacial e a matriz de pesos espaciais

-   `spatialreg`: para calcular os modelos de regressão espacial global

-   `spgrw`: para calcular o modelo de regressão espacial local

Podemos instalar os pacotes:

```{r}
#| eval: false
install.packages("tidyverse")
install.packages("sf")
install.packages("spdep")
install.packages("spatialreg")
install.packages("spgwr")
```

::: callout-warning
Atenção: dependendo da versão de R que você está usando, você pode precisar instalar o pacote `Rcpp` antes dos pacotes de análise espacial. Se você encontrar um erro na instalação dos pacotes acima, instale o pacote citado e tente novamente. Se o problema persistir, por favor entre em contato com a equipe responsável pela disciplina.

```{r}
#| eval: false
install.packages("Rcpp")
```
:::

E então carregá-los:

```{r}
#| warning: false
#| message: false 
library(tidyverse)
library(sf)
library(spdep)
library(spatialreg)
library(spgwr)
```

## Importando os dados

Para facilitar o download, você pode usar o código abaixo, que cria uma pasta chamada "dados" e baixa o arquivo geopackage para essa pasta. O arquivo será salvo com o nome `agua_rede_sf.gpkg`:

```{r}
# Criando a pasta para armazenar os dados
fs::dir_create("dados")

# Download do arquivo geopackage
download.file("https://github.com/beatrizmilz/ESHT011-21-analise-dados-planejamento-territorial/raw/refs/heads/main/praticas/dados/agua_rede_sf.gpkg", 
              destfile = "dados/agua_rede_sf.gpkg", 
              mode = "wb")
```

A base de dados está em formato geopackage (.gpkg) e pode ser importada com a função `read_sf()`.

```{r}
agua_rede_sf <- read_sf("dados/agua_rede_sf.gpkg")
```

## Explorando os dados

Os arquivos geoespaciais que trabalharemos são chamados de simple features (sf) no R. A sua estrutura é semelhante à de uma tabela, mas trazendo informações do Sistema de Referência de Coordenadas (CRS) e uma variável adicional: a geometria (geom ou geometry), com as coordenadas que permitem mapear os pontos, linhas ou polígonos.

Executando o nome do objeto é possível obter algumas dessas informações.

```{r}
agua_rede_sf
```

A função `names()` exibe os nomes das variáveis.

```{r}
names(agua_rede_sf)
```

Os nomes das variáveis estão codificados, apresentando correspondência às variáveis descritas abaixo:

| Código | Descrição |
|----------------|--------------------------------------------------------|
| ID_IBGE | Código IBGE (7 dígitos) |
| DOMICIL | Quantidade de Domicílios |
| REDE | Quantidade de Domicílios com Acesso à Rede Geral de Água |
| PROPREDE | Proporção de Domicílios com com Acesso à Rede Geral de Água (REDE/DOMICIL) |
| ID_SNIS | Código IBGE (6 dígitos) |
| NOME_MUN | Nome do Município |
| UF | Unidade da Federação |
| REGIAO | Região do País |
| PIB | Produto Interno Bruto 2010 |
| RENDAPITA | Renda per Capita 2010 |
| GINI | Índice GINI 2010 |
| IDH | Índice de Desenvolvimento Humano 2010 |
| IDH_CLASS | Classificação do Índice de Desenvolvimento Humano 2010: Muito Alto \>= 0,9; Alto \>= 0,8; Médio \>= 0,5; Baixo \< 0,5. |
| GE012 | População Total Residente no Município |
| AG001 | População Total Atendida com Abastecimento de Água |
| AG020 | Volume Micromedido nas Economias Residenciais Ativas de Agua - 1.000 m3/ano |
| AG022 | Quantidade de Economias Residenciais Ativas Micromedidas |
| CONSUMO1 | Consumo de Água per capita - População Total - m3/ano (AG020/GE012) |
| CONSUMO2 | Consumo de Água per capita - População Atendida - m3/ano (AG020/AG001) |

Além delas, estão presentes outras variáveis que trazem os resultados do modelo de regressão linear (.fitted, .resid, .std.resid, .hat, .sigma, .cooksd), conforme apresentado no [Roteiro 5](https://luisfelipebr.github.io/mti2020/roteiros/roteiro5.html).

**ATENÇÃO: Algumas considerações sobre os dados antes de rodar o modelo:**

1.  O modelo não vai funcionar em uma base de dados com valores faltantes (NA).
2.  É necessário trazer em uma coluna as coordenadas do centróide dos polígonos (longitude/latitude).
3.  Os modelos de regressão espacial são complexos e exigem um tempo de processamento muito maior que os modelos lineares! Nos nossos testes, o tempo de processamento variou entre 10 a 30 minutos. Portanto, recomendamos rodar o modelo apenas em uma amostra dos dados (ex: `UF == "SP"`).

As funções apresentadas nas aulas anteriores funcionam em dados geoespaciais de forma semelhante à tabelas. Vamos usá-las para resolver a primeira e segunda consideração.

Para filtrar apenas as observações completas, ou seja, sem valores faltantes (NA), podemos aplicar a função `drop_na()`, levando em consideração as variáveis que serão utilizadas (ID, Variável Y e Variável X), para remover as linhas que contém `NA` nas variáveis indicadas.

```{r}
agua_rede_sf_sem_na <- agua_rede_sf |>
  drop_na(ID_IBGE, CONSUMO1, RENDAPITA)
```

Dos `r nrow(agua_rede_sf)` municípios presentes na base de dados, apenas `r nrow(agua_rede_sf_sem_na)` tinham informações completas do ID_IBGE, CONSUMO1 e RENDAPITA. O modelo será aplicado apenas nessas observações.

**Amostragem:** o código abaixo cria uma amostra apenas com os dados do estado de São Paulo.

```{r}
agua_rede_sf_sp <- agua_rede_sf_sem_na |>
  filter(UF == "SP")
```

Para executar o modelo de regressão espacial local (GWR), é necessário ter variáveis que descrevem a longitude e latitude do centróide dos polígonos.

A função `st_centroid()` calcula o centróide de um polígono, porém ela só funciona se as geometrias forem consideradas "válidas". Podemos fazer essa checagem com a função `st_is_valid()`:

```{r}
# Checando se a geometria é valida
geometrias_validas <- st_is_valid(agua_rede_sf_sp)

# Somando quantas geometrias são inválidas
sum(geometrias_validas == FALSE)
```

Agora podemos calcular o centróide:

```{r}
agua_rede_sf_sp_centroide <- agua_rede_sf_sp |>
  mutate(LON = st_coordinates(st_centroid(agua_rede_sf_sp))[,1],
         LAT = st_coordinates(st_centroid(agua_rede_sf_sp))[,2])
```

Agora temos as colunas `LAT` e `LON`, mantendo a coluna `geom`:

```{r}
agua_rede_sf_sp_centroide |> 
  select(LAT, LON, geom)
```

## Modelos de regressão espacial global (Spatial Lag e Spatial Error)

Após a análise espacial dos resíduos - que permitiu observar que as observações não são independentes espacialmente, vamos incorportar a estrutura de dependência espacial no modelo.

Os modelos globais incluem no modelo de regressão um parâmetro para capturar a estrutura de autocorrelação espacial na área de estudo como um todo.

O Spatial Lag (SAR) atribue a autocorrelação espacial à variável resposta Y (lag), enquanto o Spatial Error (CAR) atribue a autocorrelação espacial ao erro.

### Preparando os dados

O ponto de partida para o Spatial Lag e Spatial Error é o modelo de regressão linear (Roteiro 5), criado com a função `lm()`.

```{r}
modelo1 <- lm(formula = CONSUMO1 ~ RENDAPITA, 
              data = agua_rede_sf_sp_centroide, 
              na.action = na.exclude)
```

Também é necessário criar um arquivo com a lista de vizinhança, com a função `poly2nb()`. Foi usado o critério de vizinhança do tipo `queen`. Para usar outros critérios, lembre-se de consultar a documentação da função.

```{r}
vizinhanca <- poly2nb(pl = agua_rede_sf_sp_centroide, 
             row.names = agua_rede_sf_sp_centroide$ID_IBGE)
```

Visualizando o sumário desse arquivo, é possível ter uma ideia da distribuição da vizinhança.

```{r}
summary(vizinhanca)
```

Agora é possível criar uma matriz de pesos espaciais, com as funções `nb2mat()` e `mat2listw()`. Em vários momentos é necessário definir o argumento adicional `zero.policy = TRUE`, que permite obter os resultados mesmo que uma ou mais observações não tenham nenhum vizinho. Não se esqueça de adicionar este parâmetro sempre que indicado neste roteiro.

```{r}
wm <- nb2mat(neighbours = vizinhanca, style='B', zero.policy = TRUE)

rwm <- mat2listw(x = wm, style='W', zero.policy = TRUE)
```

Agora já é possível realizar o teste de autocorrelação espacial dos resíduos, com a função `lm.morantest()`, que levará como argumentos: o modelo (modelo1), a matriz de pesos espaciais (rwm) e a tipo de hipótese alternativa ("two-sided", que representa o teste bicaudal).

```{r}
lm.morantest(model = modelo1, 
             listw = rwm, 
             alternative = "two.sided",
             zero.policy = TRUE)
```

O resultado do teste é significativo (p-valor \< 0,00000000000000022), portanto há dependência espacial nos resíduos e um modelo de regressão espacial global pode ser aplicado.

Mas antes disso serão aplicados quatro testes de hipótese para identificar qual é o modelo mais adequado (Spatial Lag ou Spatial Error):

-   LMerr: teste LM simples para dependência do erro
-   LMlag: teste LM simples para uma variável dependente espacialmente defasada
-   RLMerr: teste LM robusto para dependência do erro
-   RLMlag: teste LM robusto para uma variável dependente espacialmente defasada

```{r}
lm.LMtests(model = modelo1,
          listw = rwm,
          test = c("LMerr","LMlag","RLMerr","RLMlag"),
          zero.policy = TRUE)
```

Como interpretar os resultados dos testes de hipótese dos multiplicadores de Lagrange?

Primeiro examinamos os testes simples (LMerr e LMlag). Se eles não forem significativos (p-valor \> 0,05), a hipótese de modelagem do erro ou lag não se sustenta. Se apenas um deles for significativo (p-valor \< 0,05): problema resolvido - mas é bastante comum que ambos sejam significativos. Se ambos forem significativos, é necessário conferir os testes robustos.

Olhando para os multiplicadores de Lagrange robustos (RLMlag e RLMerr), normalmente, apenas um deles será significativo, ou um terá uma ordem de magnitude mais significativo do que o outro (por exemplo, p \< 0,000003 em comparação com p \< 0,03). Nesse caso, a decisão é simples: estimar o modelo de regressão espacial correspondendo à estatística mais "robusta" (ou significativa). No caso raro de ambos serem altamente significativos, escolha o modelo com o maior valor para a estatística de teste. No entanto, nesta situação, é necessário algum cuidado, uma vez que podem existir outras fontes de erros de especificação. Outra ação a se tomar é alterar a especificação básica (ou seja, a parte não espacial) do modelo.

Também há casos raros em que nenhuma das estatísticas do teste robusto é significativa. Nesses casos, problemas de especificação mais sérios provavelmente estão presentes e devem ser resolvidos primeiro. Por outros erros de especificação, nos referimos a problemas com algumas das outras suposições da regressão linear (Roteiro 5).

Neste caso, os dois testes simples são significativos. Mas o teste de erro robusto é mais significativo que o teste de lag robusto, então o modelo mais apropriado seria o Spatial Error (CAR). De qualquer forma, vamos ensinar a aplicar os dois modelos (SAR e CAR) na sequência.

### Spatial Autoregressive Model (Spatial Lag/SAR)

Para aplicar o modelo Spatial Lag usaremos a função `lagsarlm()`, especificando a fórmula, os dados e a matriz de pesos espaciais.

```{r}
sar_modelo <- lagsarlm(formula = CONSUMO1 ~ RENDAPITA,
                       data = agua_rede_sf_sp_centroide,
                       listw = rwm,
                       zero.policy = TRUE)
```

Para ver os resultados do novo modelo, você pode acessar o sumário.

```{r}
summary(sar_modelo)
```

O modelo SAR possui um melhor desempenho que o modelo de regressão linear, indicado pelo AIC (4130), que é menor que o AIC do modelo de regressão linear (4188). Além disso, o teste de autocorrelação espacial dos resíduos não é significativo (p-valor = 0,16), indicando que após a modelagem os resíduos não são mais correlacionados espacialmente.

### Conditional Autoregressive Model (Spatial Error/CAR)

Para aplicar o modelo Spatial Error usaremos a função `errorsarlm()`, especificando a fórmula, os dados e a matriz de pesos espaciais.

```{r}
car_modelo <- errorsarlm(formula = CONSUMO1 ~ RENDAPITA,
                        data = agua_rede_sf_sp_centroide,
                        listw = rwm,
                        zero.policy = TRUE)
```

É possível visualizar os resultados do modelo usando o sumário.

```{r}
summary(car_modelo)
```

O AIC do modelo CAR (4120) é menor que o AIC do modelo de regressão linear (4188), indicando um melhor resultado. Além disso, todos os valores estimados são significativos (p-valor \< 0,05).

### Exportando os resíduos do modelo

Para verificar a autocorrelação espacial no GeoDa, é necessário exportar os resíduos do modelo. O código abaixo indica como executar essa etapa para os dois modelos, criando as variáveis (colunas) sar_residuos e car_residuos.

```{r}
agua_rede_sar_car <- agua_rede_sf_sp_centroide |>
  mutate(sar_residuos = residuals(sar_modelo),
         car_residuos = residuals(car_modelo))
```

Após criar essa nova base de dados, você pode exportá-la como geopackage ou shapefile com a função `write_sf()`.

```{r, eval=FALSE}
write_sf(agua_rede_sar_car, "dados/agua_rede_sar_car.gpkg")
```

```{r, eval=FALSE}
write_sf(agua_rede_sar_car, "dados/agua_rede_sar_car.shp")
```

## Modelo de regressão espacial local (GWR)

O modelo de regressão espacial local ou Geographically Weighted Regression (GWR) incorpora a estrutura de dependência espacial (verificada com o teste de autocorrelação espacial - Roteiro 6).

Nesse modelo, as variações espaciais são modeladas de forma contínua, com parâmetros variando no espaço. Ele ajusta um modelo de regressão para cada observação, ponderando todas as demais observações como função da distância a este ponto. Existe uma função (kernel) sobre cada ponto do espaço que determina todos os pontos da regressão local que é ponderada pela distância. Pontos mais próximos do ponto central tem maior peso. Assim como no kernel, a escolha da largura da banda é importante, pondendo ser fixa ou adaptável à densidade dos dados.

O processo de modelagem envolverá quatro etapas: (1) estimativa do kernel, (2) cômputo do modelo, (3) análise do sumário do modelo e (4) exportação dos resultados para análise espacial no QGIS.

É possível obter a melhor estimativa do kernel com a função `gwr.sel()`. Como argumentos, indicamos a fórmula, os dados, as coordenadas dos centróides e indicamos que a largura da banda será adaptativa (`adapt = TRUE`). O resultado será salvo no objeto `gwr_kernel`.

```{r}
#| cache: true
gwr_kernel <- gwr.sel(formula = CONSUMO1 ~ RENDAPITA, 
                        data = agua_rede_sf_sp_centroide,
                        coords = cbind(agua_rede_sf_sp_centroide$LON,
                                       agua_rede_sf_sp_centroide$LAT),
                        adapt = TRUE)
```

Após obter a melhor estimativa para o kernel, é possível fazer a modelagem com a função `gwr()`. Além da fórmula, dados e coordenadas, é necessário indicar o kernel (`adapt = gwr_kernel`) e dois argumentos adicionais para salvar os resultados completos.

```{r}
gwr_modelo <- gwr(formula = CONSUMO1 ~ RENDAPITA,
                data = agua_rede_sf_sp_centroide,
                coords = cbind(agua_rede_sf_sp_centroide$LON,
                               agua_rede_sf_sp_centroide$LAT),
                adapt = gwr_kernel, 
                hatmatrix = TRUE,
                se.fit = TRUE)
```

É possível visualizar o sumário com alguns resultados executando como comando o nome do objeto onde o modelo foi salvo, `gwr_modelo`.

```{r}
gwr_modelo
```

Duas estatísticas muito importantes sobre o modelo são o AIC e o R². Neste caso o AIC do modelo de regressão espacial local (4083) é menor que o AIC do modelo de regressão linear (4188), indicando um melhor resultado. O R² "quasi-global" (0,37) é maior que o R² do modelo de regressão linear (0,21), também indicando um melhor resultado.

Também é importante verificar os parâmetros locais estimados e o coeficiente local de determinação (R²). Para visualizar esses parâmetros, vamos exportar uma nova base de dados (em formato geopackage ou shapefile) para abrir e visualizar no QGIS.

O código abaixo indica como executar essa última etapa.

```{r}
agua_rede_gwr <- cbind(agua_rede_sf_sp_centroide,
                       as.matrix(as.data.frame(gwr_modelo$SDF))) |>
  mutate(t_beta1 = RENDAPITA.1 / RENDAPITA_se)
```

As novas variáveis são:

-   `X.Intercept` = valores locais de beta zero (intercepto)
-   `RENDAPITA.1` = valores locais do coeficiente de renda per capita (X1)
-   `X.Intercept_se` = erro padrão de beta zero (intercepto)
-   `RENDAPITA_se` = erro padrão do coeficiente estimado para renda per capita (X1)
-   `t_beta1` = estatística t local para o coeficiente de renda per capita
-   `pred` = valores previstos de Y
-   `localR2` = valores locais de R2

Para interpretar os resultados do GWR, é importante mapear algumas estatísticas, tais como o R2 local, os coeficientes beta e estatísticas t.

Para obter a estatística t para cada coeficiente beta, deve-se dividir os valores dos coeficientes (por exemplo, RENDAPITA.1) por seus respectivos erros padrão (RENDAPITA_se). Se o módulo da estatística t for maior do que o valor do t crítico, pode-se rejeitar a hipótese nula de que beta é igual a zero (ou seja, beta é significativo).

A variável "pred" apresenta os parâmetros locais estimados para a variável Renda per capita, enquanto a variável "localR2" apresenta o coeficiente local de determinação (R²). Também é interessante aplicar um teste de autocorrelação espacial nos resíduos, para verificar se a dependência espacial foi resolvida pelo modelo.

Para exportar como geopackage:

```{r, eval = FALSE}
write_sf(agua_rede_gwr, "dados/agua_rede_gwr.gpkg")
```

Para exportar como shapefile:

```{r, eval = FALSE}
write_sf(agua_rede_gwr, "dados/agua_rede_gwr.shp")
```

## Sugestões de materiais

- [Dados espaciais no R](https://ipeadata-lab.github.io/curso_r_intermediario_202501/dados-espaciais.html) - material do curso "R intermediário e pesquisa reprodutível"


